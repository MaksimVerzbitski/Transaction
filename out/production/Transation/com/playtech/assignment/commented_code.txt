package com.playtech.assignment;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;


// This template shows input parameters format.
// It is otherwise not mandatory to use, you can write everything from scratch if you wish.
public class TransactionProcessorSample {
    // Global variables to track IBANs used for deposits and account number usage
    static Map<String, Set<String>> userIbans = new HashMap<>();
    static Map<String, String> accountUsers = new HashMap<>();

    public static void main(final String[] args) throws IOException {
        List<User> users = TransactionProcessorSample.readUsers(Paths.get(args[0]));
        List<Transaction> transactions = TransactionProcessorSample.readTransactions(Paths.get(args[1]));
        TreeMap<Long, List<BinMapping>> binMappings = TransactionProcessorSample.readBinMappings(Paths.get(args[2]));

        List<Event> events = TransactionProcessorSample.processTransactions(users, transactions, binMappings);

        TransactionProcessorSample.writeBalances(Paths.get(args[3]), users);
        TransactionProcessorSample.writeEvents(Paths.get(args[4]), events);
    }



    private static List<User> readUsers(final Path filePath) {
        List<User> users = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                User user = createUser(attributes);
                users.add(user);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return users;
    }

    private static User createUser(String[] metadata) {
        String userId = metadata[0]; // No need to parse as int
        String username = metadata[1];
        double balance = Double.parseDouble(metadata[2]);
        String country = metadata[3];
        boolean frozen = Boolean.parseBoolean(metadata[4]);
        double depositMin = Double.parseDouble(metadata[5]);
        double depositMax = Double.parseDouble(metadata[6]);
        double withdrawMin = Double.parseDouble(metadata[7]);
        double withdrawMax = Double.parseDouble(metadata[8]);
        return new User(userId, username, balance, country, frozen, depositMin, depositMax, withdrawMin, withdrawMax);
    }

    private static List<Transaction> readTransactions(final Path filePath) {
        List<Transaction> transactions = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                Transaction transaction = createTransaction(attributes);
                transactions.add(transaction);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return transactions;
    }

    private static Transaction createTransaction(String[] metadata) {
        String transactionId = metadata[0];
        String userId = metadata[1]; // Treat as String, no need for Integer.parseInt()
        String type = metadata[2];
        double amount = Double.parseDouble(metadata[3]);
        String method = metadata[4];
        String accountNumber = metadata[5];
        return new Transaction(transactionId, userId, type, amount, method, accountNumber);
    }

    private static TreeMap<Long, List<BinMapping>> readBinMappings(final Path filePath) {
        TreeMap<Long, List<BinMapping>> binMappings = new TreeMap<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true;

            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                BinMapping binMapping = createBinMapping(attributes);
                binMappings.computeIfAbsent(binMapping.getRangeFrom(), k -> new ArrayList<>()).add(binMapping);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return binMappings;
    }

    private static BinMapping createBinMapping(String[] metadata) {
        String name = metadata[0];
        long rangeFrom = Long.parseLong(metadata[1]); // Parse as long
        long rangeTo = Long.parseLong(metadata[2]);   // Parse as long
        String type = metadata[3];
        String country = metadata[4];
        return new BinMapping(name, rangeFrom, rangeTo, type, country);
    }




    private static List<Event> processTransactions(final List<User> users, final List<Transaction> transactions, TreeMap<Long, List<BinMapping>> binMappings) {
        List<Event> events = new ArrayList<>();
        Map<String, User> usersMap = users.stream().collect(Collectors.toMap(User::getUserId, user -> user));
        Set<String> processedTransactionIds = new HashSet<>();

        for (Transaction transaction : transactions) {
            // Check for previously processed transaction IDs
            if (!processedTransactionIds.add(transaction.getTransactionId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Transaction ID already processed"));
                continue;
            }

            // Check for account number usage by other users
            if (accountUsers.containsKey(transaction.getAccountNumber()) && !accountUsers.get(transaction.getAccountNumber()).equals(transaction.getUserId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Account " + transaction.getAccountNumber() + " is in use by other user"));
                continue;
            } else {
                accountUsers.put(transaction.getAccountNumber(), transaction.getUserId());
            }

            User user = usersMap.get(transaction.getUserId());
            if (user == null || user.isFrozen()) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "User account is frozen or does not exist"));
                continue;
            }

            switch (transaction.getMethod()) {
                case "CARD":
                    processCardTransaction(transaction, user, binMappings, events);
                    break;
                case "TRANSFER":
                    processTransferTransaction(transaction, user, events);
                    break;
                default:
                    events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid transaction method"));
            }
        }
        return events;
    }

    private static void processCardTransaction(Transaction transaction, User user, TreeMap<Long, List<BinMapping>> binMappings, List<Event> events) {
        // Extract the first 6 digits of the account number as the BIN
        long bin = Long.parseLong(transaction.getAccountNumber().substring(0, 6));
        String cardType = findCardType(transaction.getAccountNumber(), new ArrayList<>(binMappings.values().stream().flatMap(List::stream).collect(Collectors.toList())), user.getCountry());

        if (!"Unknown".equals(cardType)) {
            if ("CC".equals(cardType)) {
                // Handle credit card transactions
                // CC can go into negative based on withdrawal min/max and deposit min/max
                if ("WITHDRAW".equals(transaction.getType())) {
                    if (user.getBalance() - transaction.getAmount() >= -user.getWithdrawMax()) {
                        user.setBalance(user.getBalance() - transaction.getAmount());
                        events.add(new Event(transaction.getTransactionId(), "APPROVED", "Credit card withdrawal approved"));
                    } else {
                        events.add(new Event(transaction.getTransactionId(), "DECLINED", "Credit card withdrawal exceeds limit"));
                    }
                } else if ("DEPOSIT".equals(transaction.getType())) {
                    if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                        user.setBalance(user.getBalance() + transaction.getAmount());
                        events.add(new Event(transaction.getTransactionId(), "APPROVED", "Credit card deposit approved"));
                    } else {
                        events.add(new Event(transaction.getTransactionId(), "DECLINED", "Deposit amount out of allowed range for credit card"));
                    }
                }
            } else if ("DC".equals(cardType)) {
                // Handle debit card transactions
                // DC transactions must have a positive balance
                if ("WITHDRAW".equals(transaction.getType())) {
                    if (user.getBalance() >= transaction.getAmount() && transaction.getAmount() >= user.getWithdrawMin() && transaction.getAmount() <= user.getWithdrawMax()) {
                        user.setBalance(user.getBalance() - transaction.getAmount());
                        events.add(new Event(transaction.getTransactionId(), "APPROVED", "Debit card withdrawal approved"));
                    } else {
                        events.add(new Event(transaction.getTransactionId(), "DECLINED", "Insufficient funds or amount out of allowed range for debit card"));
                    }
                } else if ("DEPOSIT".equals(transaction.getType())) {
                    if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                        user.setBalance(user.getBalance() + transaction.getAmount());
                        events.add(new Event(transaction.getTransactionId(), "APPROVED", "Debit card deposit approved"));
                    } else {
                        events.add(new Event(transaction.getTransactionId(), "DECLINED", "Deposit amount out of allowed range for debit card"));
                    }
                }
            }
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid card BIN or card type"));
        }
    }

    private static void processTransferTransaction(Transaction transaction, User user, List<Event> events) {
        // Track IBANs for deposits
        if ("DEPOSIT".equals(transaction.getType())) {
            userIbans.computeIfAbsent(user.getUserId(), k -> new HashSet<>()).add(transaction.getAccountNumber());
        }

        // Check for withdrawals using only previously used IBANs
        if ("WITHDRAW".equals(transaction.getType())) {
            if (!userIbans.getOrDefault(user.getUserId(), Collections.emptySet()).contains(transaction.getAccountNumber())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Cannot withdraw with a new IBAN " + transaction.getAccountNumber()));
                return;
            }
        }

        // Validate IBAN for transfers
        if (isValidIBAN(transaction.getAccountNumber())) {
            String ibanCountryCode = transaction.getAccountNumber().substring(0, 2);
            if (!ibanCountryCode.equals(user.getCountry())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid account country for IBAN: " + ibanCountryCode + ", expected: " + user.getCountry()));
                return;
            }
            processTransactionApproval(transaction, user, events);
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid IBAN for transfer"));
        }
    }

    private static void processTransactionApproval(Transaction transaction, User user, List<Event> events) {
        if ("DEPOSIT".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                user.setBalance(user.getBalance() + transaction.getAmount());
                events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
            } else {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Deposit amount out of allowed range"));
            }
        } else if ("WITHDRAW".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getWithdrawMin() && transaction.getAmount() <= user.getWithdrawMax()) {
                if (transaction.getAmount() <= user.getBalance()) {
                    user.setBalance(user.getBalance() - transaction.getAmount());
                    events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
                } else {
                    events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal exceeds balance"));
                }
            } else {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal amount out of allowed range"));
            }
        }
    }



    private static void writeBalances(final Path filePath, final List<User> users) throws IOException {
        try (final FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("userId,balance\n");
            for (final User user : users) {
                writer.append(String.valueOf(user.getUserId()))
                        .append(",").append(String.valueOf(user.getBalance()))
                        .append("\n");
            }
        }
    }

    private static void writeEvents(Path filePath, List<Event> events) throws IOException {
        try (FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("transaction_id,status,message\n");
            for (Event event : events) {
                writer.append(event.getTransactionId())
                        .append(",").append(event.getStatus())
                        .append(",").append(event.getMessage())
                        .append("\n");
            }
        }
    }

    public static boolean isValidIBAN(String iban) {
        Map<String, String> ibanPatterns = new HashMap<>();

        // Inserting the full list of IBAN regex patterns
        ibanPatterns.put("AL", "^AL\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("AD", "^AD\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("AT", "^AT\\d{18}$");
        ibanPatterns.put("AZ", "^AZ\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("BH", "^BH\\d{2}[A-Z]{4}[0-9A-Z]{14}$");
        ibanPatterns.put("BE", "^BE\\d{14}$");
        ibanPatterns.put("BA", "^BA\\d{18}$");
        ibanPatterns.put("BR", "^BR\\d{25}[A-Z][0-9A-Z]$");
        ibanPatterns.put("BG", "^BG\\d{2}[A-Z]{4}\\d{6}[0-9A-Z]{8}$");
        ibanPatterns.put("CR", "^CR\\d{20}$");
        ibanPatterns.put("HR", "^HR\\d{19}$");
        ibanPatterns.put("CY", "^CY\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("CZ", "^CZ\\d{22}$");
        ibanPatterns.put("FO", "^FO\\d{16}$");
        ibanPatterns.put("GL", "^GL\\d{16}$");
        ibanPatterns.put("DK", "^DK\\d{16}$");
        ibanPatterns.put("DO", "^DO\\d{2}[0-9A-Z]{4}\\d{20}$");
        ibanPatterns.put("EE", "^EE\\d{18}$");
        ibanPatterns.put("EG", "^EG\\d{27}$");
        ibanPatterns.put("FI", "^FI\\d{16}$");
        ibanPatterns.put("FR", "^FR\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("GE", "^GE\\d{2}[A-Z]{2}\\d{16}$");
        ibanPatterns.put("DE", "^DE\\d{20}$");
        ibanPatterns.put("GI", "^GI\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("GR", "^GR\\d{9}[0-9A-Z]{16}$");
        ibanPatterns.put("GT", "^GT\\d{2}[0-9A-Z]{24}$");
        ibanPatterns.put("HU", "^HU\\d{26}$");
        ibanPatterns.put("IS", "^IS\\d{24}$");
        ibanPatterns.put("IE", "^IE\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("IL", "^IL\\d{21}$");
        ibanPatterns.put("IT", "^IT\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("JO", "^JO\\d{2}[A-Z]{4}\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("KZ", "^KZ\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("XK", "^XK\\d{18}$");
        ibanPatterns.put("KW", "^KW\\d{2}[A-Z]{4}[0-9A-Z]{22}$");
        ibanPatterns.put("LV", "^LV\\d{2}[A-Z]{4}[0-9A-Z]{13}$");
        ibanPatterns.put("LB", "^LB\\d{6}[0-9A-Z]{20}$");
        ibanPatterns.put("LI", "^LI\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("LT", "^LT\\d{18}$");
        ibanPatterns.put("LU", "^LU\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("MK", "^MK\\d{5}[0-9A-Z]{10}\\d{2}$");
        ibanPatterns.put("MT", "^MT\\d{2}[A-Z]{4}\\d{5}[0-9A-Z]{18}$");
        ibanPatterns.put("MR", "^MR\\d{25}$");
        ibanPatterns.put("MU", "^MU\\d{2}[A-Z]{4}\\d{19}[A-Z]{3}$");
        ibanPatterns.put("MD", "^MD\\d{2}[0-9A-Z]{20}$");
        ibanPatterns.put("MC", "^MC\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("ME", "^ME\\d{20}$");
        ibanPatterns.put("NL", "^NL\\d{2}[A-Z]{4}\\d{10}$");
        ibanPatterns.put("NO", "^NO\\d{13}$");
        ibanPatterns.put("PK", "^PK\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("PS", "^PS\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("PL", "^PL\\d{26}$");
        ibanPatterns.put("PT", "^PT\\d{23}$");
        ibanPatterns.put("QA", "^QA\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("RO", "^RO\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("SM", "^SM\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("LC", "^LC\\d{2}[A-Z]{4}[0-9A-Z]{24}$");
        ibanPatterns.put("ST", "^ST\\d{23}$");
        ibanPatterns.put("SA", "^SA\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("RS", "^RS\\d{20}$");
        ibanPatterns.put("SK", "^SK\\d{22}$");
        ibanPatterns.put("SI", "^SI\\d{17}$");
        ibanPatterns.put("ES", "^ES\\d{22}$");
        ibanPatterns.put("SE", "^SE\\d{22}$");
        ibanPatterns.put("CH", "^CH\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("TL", "^TL\\d{21}$");
        ibanPatterns.put("TN", "^TN\\d{22}$");
        ibanPatterns.put("TR", "^TR\\d{7}[0-9A-Z]{17}$");
        ibanPatterns.put("AE", "^AE\\d{21}$");
        ibanPatterns.put("GB", "^GB\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("VA", "^VA\\d{20}$");
        ibanPatterns.put("VG", "^VG\\d{2}[A-Z]{4}\\d{16}$");
        ibanPatterns.put("UA", "^UA\\d{8}[0-9A-Z]{19}$");
        ibanPatterns.put("SC", "^SC\\d{2}[A-Z]{4}\\d{20}[A-Z]{3}$");
        ibanPatterns.put("IQ", "^IQ\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("BY", "^BY\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("SV", "^SV\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("LY", "^LY\\d{23}$");
        ibanPatterns.put("SD", "^SD\\d{16}$");
        ibanPatterns.put("BI", "^BI\\d{2}[0-9A-Z]{10}[0-9A-Z]{12}$");
        ibanPatterns.put("DJ", "^DJ\\d{25}$");
        ibanPatterns.put("RU", "^RU\\d{2}[0-9A-Z]{20}[0-9A-Z]{9}$");

        // Validate IBAN format
        if (iban.length() < 2) return false; // IBAN too short to contain a valid country code
        String countryCode = iban.substring(0, 2);
        String regexPattern = ibanPatterns.get(countryCode);
        return regexPattern != null && iban.matches(regexPattern);
    }


    private static Map<String, String> initializeCountryCodes() {
        Map<String, String> codes = new HashMap<>();
        codes.put("USA", "US"); // United States
        codes.put("GBR", "GB"); // United Kingdom
        codes.put("BRA", "BR"); // Brazil
        codes.put("CHL", "CL"); // Chile
        codes.put("EGY", "EG"); // Egypt
        codes.put("LBN", "LB"); // Lebanon
        codes.put("BGD", "BD"); // Bangladesh
        codes.put("IND", "IN"); // India
        codes.put("LKA", "LK"); // Sri Lanka
        codes.put("NPL", "NP"); // Nepal
        codes.put("SGP", "SG"); // Singapore
        codes.put("RUS", "RU"); // Russia
        codes.put("MMR", "MM"); // Myanmar
        codes.put("VNM", "VN"); // Vietnam
        codes.put("ARG", "AR"); // Argentina
        codes.put("JPN", "JP"); // Japan
        codes.put("MAR", "MA"); // Morocco
        codes.put("AUS", "AU"); // Australia
        codes.put("MYS", "MY"); // Malaysia
        codes.put("HUN", "HU"); // Hungary
        codes.put("KOR", "KR"); // South Korea
        codes.put("HKG", "HK"); // Hong Kong
        codes.put("IDN", "ID"); // Indonesia
        codes.put("PER", "PE"); // Peru
        codes.put("QAT", "QA"); // Qatar
        codes.put("LCA", "LC"); // Saint Lucia
        codes.put("VCT", "VC"); // Saint Vincent and the Grenadines
        codes.put("DMA", "DM"); // Dominica
        codes.put("GRD", "GD"); // Grenada
        codes.put("ECU", "EC"); // Ecuador
        codes.put("COL", "CO"); // Colombia
        codes.put("CHE", "CH"); // Switzerland
        codes.put("ESP", "ES"); // Spain
        codes.put("BRB", "BB"); // Barbados
        codes.put("PRY", "PY"); // Paraguay
        codes.put("FIN", "FI"); // Finland
        codes.put("BEL", "BE"); // Belgium
        codes.put("NLD", "NL"); // Netherlands
        codes.put("TUR", "TR"); // Turkey
        codes.put("ARE", "AE"); // United Arab Emirates
        codes.put("DOM", "DO"); // Dominican Republic
        codes.put("ZAF", "ZA"); // South Africa
        codes.put("PRI", "PR"); // Puerto Rico
        codes.put("FRA", "FR"); // France
        codes.put("CUW", "CW"); // Curaçao
        codes.put("VEN", "VE"); // Venezuela
        codes.put("JAM", "JM"); // Jamaica
        codes.put("TCA", "TC"); // Turks and Caicos Islands
        codes.put("TTO", "TT"); // Trinidad and Tobago
        codes.put("BOL", "BO"); // Bolivia
        codes.put("THA", "TH"); // Thailand
        codes.put("CAN", "CA"); // Canada
        codes.put("ITA", "IT"); // Italy
        codes.put("GGY", "GG"); // Guernsey
        codes.put("JEY", "JE"); // Jersey
        codes.put("DNK", "DK"); // Denmark
        codes.put("NOR", "NO"); // Norway
        codes.put("SWE", "SE"); // Sweden
        codes.put("AUT", "AT"); // Austria
        codes.put("GRC", "GR"); // Greece
        codes.put("DEU", "DE"); // Germany
        codes.put("CHN", "CN"); // China
        codes.put("PRT", "PT"); // Portugal
        codes.put("BHR", "BH"); // Bahrain
        codes.put("IRQ", "IQ"); // Iraq
        codes.put("JOR", "JO"); // Jordan
        codes.put("CYP", "CY"); // Cyprus
        codes.put("TUN", "TN"); // Tunisia
        codes.put("ZWE", "ZW"); // Zimbabwe
        codes.put("GIB", "GI"); // Gibraltar
        codes.put("ISL", "IS"); // Iceland
        codes.put("NGA", "NG"); // Nigeria
        codes.put("KWT", "KW"); // Kuwait
        codes.put("SOM", "SO"); // Somalia
        codes.put("RWA", "RW"); // Rwanda
        codes.put("KHM", "KH"); // Cambodia
        codes.put("UGA", "UG"); // Uganda
        codes.put("MAC", "MO"); // Macao
        codes.put("ZAR", "CD"); // Congo, Democratic Republic
        codes.put("NIC", "NI"); // Nicaragua
        codes.put("ZMB", "ZM"); // Zambia
        codes.put("TWN", "TW"); // Taiwan
        codes.put("MLI", "ML"); // Mali
        codes.put("PAK", "PK"); // Pakistan
        codes.put("BLZ", "BZ"); // Belize
        codes.put("CPV", "CV"); // Cape Verde
        codes.put("MKD", "MK"); // North Macedonia
        codes.put("AGO", "AO"); // Angola
        codes.put("VIR", "VI"); // U.S. Virgin Islands
        codes.put("SEN", "SN"); // Senegal
        codes.put("ALB", "AL"); // Albania
        codes.put("SRB", "RS"); // Serbia
        codes.put("BMU", "BM"); // Bermuda
        codes.put("DJI", "DJ"); // Djibouti
        codes.put("CYM", "KY"); // Cayman Islands
        codes.put("GHA", "GH"); // Ghana
        codes.put("DZA", "DZ"); // Algeria
        codes.put("YEM", "YE"); // Yemen
        codes.put("PSE", "PS"); // Palestine
        codes.put("BRN", "BN"); // Brunei
        codes.put("SUR", "SR"); // Suriname
        codes.put("ATG", "AG"); // Antigua and Barbuda
        codes.put("ABW", "AW"); // Aruba
        codes.put("MNG", "MN"); // Mongolia
        codes.put("MWI", "MW"); // Malawi
        codes.put("GNQ", "GQ"); // Equatorial Guinea
        codes.put("SMR", "SM"); // San Marino
        codes.put("BIH", "BA"); // Bosnia and Herzegovina
        codes.put("SDN", "SD"); // Sudan
        codes.put("OMN", "OM"); // Oman
        codes.put("LAO", "LA"); // Laos
        codes.put("NAM", "NA"); // Namibia
        codes.put("MDG", "MG"); // Madagascar
        codes.put("QZZ", ""); // Special case, needs to be handled or excluded
        codes.put("LBR", "LR"); // Liberia
        codes.put("MRT", "MR"); // Mauritania
        codes.put("COM", "KM"); // Comoros
        codes.put("SWZ", "SZ"); // Eswatini
        codes.put("COG", "CG"); // Congo
        codes.put("GMB", "GM"); // Gambia
        codes.put("SLE", "SL"); // Sierra Leone
        codes.put("LSO", "LS"); // Lesotho
        codes.put("ASM", "AS"); // American Samoa
        codes.put("SXM", "SX"); // Sint Maarten
        codes.put("BES", "BQ"); // Bonaire, Sint Eustatius, and Saba
        codes.put("ETH", "ET"); // Ethiopia
        codes.put("KIR", "KI"); // Kiribati
        codes.put("CIV", "CI"); // Côte d'Ivoire
        codes.put("BEN", "BJ"); // Benin
        codes.put("BFA", "BF"); // Burkina Faso
        codes.put("KNA", "KN"); // Saint Kitts and Nevis
        codes.put("VUT", "VU"); // Vanuatu
        codes.put("BDI", "BI"); // Burundi
        codes.put("MOZ", "MZ"); // Mozambique
        codes.put("TGO", "TG"); // Togo
        codes.put("GAB", "GA"); // Gabon
        codes.put("GIN", "GN"); // Guinea
        codes.put("NER", "NE"); // Niger
        codes.put("CAF", "CF"); // Central African Republic
        codes.put("TCD", "TD"); // Chad
        codes.put("COK", "CK"); // Cook Islands
        codes.put("PNG", "PG"); // Papua New Guinea
        codes.put("WSM", "WS"); // Samoa
        codes.put("SSD", "SS"); // South Sudan
        codes.put("VAT", "VA"); // Vatican City
        codes.put("MCO", "MC"); // Monaco
        codes.put("AND", "AD"); // Andorra
        codes.put("AIA", "AI"); // Anguilla
        codes.put("VGB", "VG"); // British Virgin Islands
        codes.put("FJI", "FJ"); // Fiji
        codes.put("BTN", "BT"); // Bhutan
        codes.put("MNP", "MP"); // Northern Mariana Islands

        return codes;
    }

    private static String findCardType(String cardNumber, List<BinRange> binRanges, String userCountry) {
        long bin = Long.parseLong(cardNumber.substring(0, 6)); // Extracting BIN
        Map<String, String> countryCodes = initializeCountryCodes();

        for (BinRange binRange : binRanges) {
            if (bin >= binRange.getRangeFrom() && bin <= binRange.getRangeTo()) {
                String binCountry = countryCodes.get(binRange.getCountry()); // Convert 3-letter to 2-letter if necessary
                if (binCountry != null && binCountry.equals(userCountry)) {
                    return binRange.getType(); // Return "CC" or "DC"
                }
            }
        }

        return "Unknown";
    }
}





class User {
    private String userId;
    private String username;
    private double balance;
    private String country;
    private boolean frozen;
    private double depositMin;
    private double depositMax;
    private double withdrawMin;
    private double withdrawMax;

    // Constructor
    public User(String userId, String username, double balance, String country, boolean frozen, double depositMin, double depositMax, double withdrawMin, double withdrawMax) {
        this.userId = userId;
        this.username = username;
        this.balance = balance;
        this.country = country;
        this.frozen = frozen;
        this.depositMin = depositMin;
        this.depositMax = depositMax;
        this.withdrawMin = withdrawMin;
        this.withdrawMax = withdrawMax;
    }
    // Getters and setters for each field
    public String getUserId() {
        return userId;
    }

    public String getUsername() {
        return username;
    }

    public double getBalance() {
        return balance;
    }

    public String getCountry() {
        return country;
    }

    public boolean isFrozen() {
        return frozen;
    }

    public double getDepositMin() {
        return depositMin;
    }

    public double getDepositMax() {
        return depositMax;
    }

    public double getWithdrawMin() {
        return withdrawMin;
    }

    public double getWithdrawMax() {
        return withdrawMax;
    }

    // Setters
    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public void setFrozen(boolean frozen) {
        this.frozen = frozen;
    }

    public void setDepositMin(double depositMin) {
        this.depositMin = depositMin;
    }

    public void setDepositMax(double depositMax) {
        this.depositMax = depositMax;
    }

    public void setWithdrawMin(double withdrawMin) {
        this.withdrawMin = withdrawMin;
    }

    public void setWithdrawMax(double withdrawMax) {
        this.withdrawMax = withdrawMax;
    }
}

class Transaction {
    private String transactionId;
    private String userId;
    private String type;
    private double amount;
    private String method;
    private String accountNumber;

    // Adjusted constructor
    public Transaction(String transactionId, String userId, String type, double amount, String method, String accountNumber) {
        this.transactionId = transactionId;
        this.userId = userId;
        this.type = type;
        this.amount = amount;
        this.method = method;
        this.accountNumber = accountNumber;
    }

    // Getters
    public String getTransactionId() {
        return transactionId;
    }

    public String getUserId() {
        return userId;
    }

    public String getType() {
        return type;
    }

    public double getAmount() {
        return amount;
    }

    public String getMethod() {
        return method;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    // Setters
    public void setTransactionId(String transactionId) {
        this.transactionId = transactionId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }
}

class BinMapping {
    private String name;
    private long rangeFrom;
    private long rangeTo;
    private String type;
    private String country;

    // Constructor
    public BinMapping(String name, long rangeFrom, long rangeTo, String type, String country) {
        this.name = name;
        this.rangeFrom = rangeFrom;
        this.rangeTo = rangeTo;
        this.type = type;
        this.country = country;
    }

    // Getters and setters
    public String getName() {
        return name;
    }

    public long getRangeFrom() {
        return rangeFrom;
    }

    public long getRangeTo() {
        return rangeTo;
    }

    public String getType() {
        return type;
    }

    public String getCountry() {
        return country;
    }

    // Setters
    public void setName(String name) {
        this.name = name;
    }

    public void setRangeFrom(long rangeFrom) {
        this.rangeFrom = rangeFrom;
    }

    public void setRangeTo(long rangeTo) {
        this.rangeTo = rangeTo;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}

class Event {
    String transactionId;
    String status;
    String message;

    public Event(String transactionId, String status, String message) {
        this.transactionId = transactionId;
        this.status = status;
        this.message = message;
    }

    // Getters and Setters
    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}


class BinRange {
    private long rangeFrom;
    private long rangeTo;
    private String type; // "CC" or "DC"
    private String country; // 3-letter country code

    // Constructor
    public BinRange(long rangeFrom, long rangeTo, String type, String country) {
        this.rangeFrom = rangeFrom;
        this.rangeTo = rangeTo;
        this.type = type;
        this.country = country;
    }

    // Getter methods
    public long getRangeFrom() {
        return rangeFrom;
    }

    public long getRangeTo() {
        return rangeTo;
    }

    public String getType() {
        return type;
    }

    public String getCountry() {
        return country;
    }
}


#2


package com.playtech.assignment;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;
import java.io.*;
import java.nio.file.*;


// This template shows input parameters format.
// It is otherwise not mandatory to use, you can write everything from scratch if you wish.
public class TransactionProcessorSample {
    // Global variables to track IBANs used for deposits and account number usage
    static Map<String, Set<String>> userIbans = new HashMap<>();
    static Map<String, String> accountUsers = new HashMap<>();

    public static void main(final String[] args) throws IOException {
        try (FileWriter logWriter = new FileWriter("debug_logs.txt", true)) {
            log(logWriter, "Starting the Transaction Processor");

            List<User> users = readUsers(Paths.get(args[0]), logWriter);
            List<Transaction> transactions = readTransactions(Paths.get(args[1]), logWriter);
            TreeMap<Long, List<BinMapping>> binMappings = readBinMappings(Paths.get(args[2]), logWriter);

            // Update this call to include logWriter as the last argument
            List<Event> events = processTransactions(users, transactions, binMappings, logWriter);

            writeBalances(Paths.get(args[3]), users, logWriter);
            writeEvents(Paths.get(args[4]), events, logWriter);
        } catch (IOException e) {
            System.err.println("Error writing to log file: " + e.getMessage());
            e.printStackTrace();
        }
    }
    private static List<User> readUsers(final Path filePath, FileWriter logWriter) throws IOException {
        log(logWriter, "Reading users from: " + filePath);
        List<User> users = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                User user = createUser(attributes);
                users.add(user);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return users;
    }

//    private static User createUser(String[] metadata) {
//        String userId = metadata[0]; // No need to parse as int
//        String username = metadata[1];
//        double balance = Double.parseDouble(metadata[2]);
//        String country = metadata[3];
//        boolean frozen = Boolean.parseBoolean(metadata[4]);
//        double depositMin = Double.parseDouble(metadata[5]);
//        double depositMax = Double.parseDouble(metadata[6]);
//        double withdrawMin = Double.parseDouble(metadata[7]);
//        double withdrawMax = Double.parseDouble(metadata[8]);
//        return new User(userId, username, balance, country, frozen, depositMin, depositMax, withdrawMin, withdrawMax);
//    }

    private static User createUser(String[] metadata) {
        String userId = new BigInteger(metadata[0], 16).toString(); // Convert from hex to decimal
        String username = metadata[1];
        double balance = Double.parseDouble(metadata[2]);
        String country = metadata[3];
        boolean frozen = Boolean.parseBoolean(metadata[4]);
        double depositMin = Double.parseDouble(metadata[5]);
        double depositMax = Double.parseDouble(metadata[6]);
        double withdrawMin = Double.parseDouble(metadata[7]);
        double withdrawMax = Double.parseDouble(metadata[8]);
        return new User(userId, username, balance, country, frozen, depositMin, depositMax, withdrawMin, withdrawMax);
    }

    private static List<Transaction> readTransactions(final Path filePath, FileWriter logWriter) throws IOException {
        log(logWriter, "Reading transactions from: " + filePath);
        List<Transaction> transactions = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                Transaction transaction = createTransaction(attributes);
                transactions.add(transaction);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return transactions;
    }

//    private static Transaction createTransaction(String[] metadata) {
//        String transactionId = metadata[0];
//        String userId = metadata[1]; // Treat as String, no need for Integer.parseInt()
//        String type = metadata[2];
//        double amount = Double.parseDouble(metadata[3]);
//        String method = metadata[4];
//        String accountNumber = metadata[5];
//        return new Transaction(transactionId, userId, type, amount, method, accountNumber);
//    }

    private static Transaction createTransaction(String[] metadata) {
        String transactionId = new BigInteger(metadata[0], 16).toString(); // Convert from hex to decimal
        String userId = new BigInteger(metadata[1], 16).toString(); // Convert from hex to decimal
        String type = metadata[2];
        double amount = Double.parseDouble(metadata[3]);
        String method = metadata[4];
        String accountNumber = metadata[5];
        return new Transaction(transactionId, userId, type, amount, method, accountNumber);
    }

    private static TreeMap<Long, List<BinMapping>> readBinMappings(final Path filePath, FileWriter logWriter) throws IOException {
        log(logWriter, "Reading BIN mappings from: " + filePath);
        TreeMap<Long, List<BinMapping>> binMappings = new TreeMap<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true;

            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                BinMapping binMapping = createBinMapping(attributes);
                binMappings.computeIfAbsent(binMapping.getRangeFrom(), k -> new ArrayList<>()).add(binMapping);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return binMappings;
    }

    private static BinMapping createBinMapping(String[] metadata) {
        String name = metadata[0];
        long rangeFrom = Long.parseLong(metadata[1]); // Parse as long
        long rangeTo = Long.parseLong(metadata[2]);   // Parse as long
        String type = metadata[3];
        String country = metadata[4];
        return new BinMapping(name, rangeFrom, rangeTo, type, country);
    }




    private static List<Event> processTransactions(List<User> users, List<Transaction> transactions, TreeMap<Long, List<BinMapping>> binMappings, FileWriter logWriter) {
        List<Event> events = new ArrayList<>();
        Map<String, User> usersMap = users.stream().collect(Collectors.toMap(User::getUserId, user -> user));
        Set<String> processedTransactionIds = new HashSet<>();

        for (Transaction transaction : transactions) {
            if (!processedTransactionIds.add(transaction.getTransactionId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Transaction ID already processed"));
                continue;
            }

            if (accountUsers.containsKey(transaction.getAccountNumber()) && !accountUsers.get(transaction.getAccountNumber()).equals(transaction.getUserId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Account " + transaction.getAccountNumber() + " is in use by other user"));
                continue;
            } else {
                accountUsers.put(transaction.getAccountNumber(), transaction.getUserId());
            }

            User user = usersMap.get(transaction.getUserId());
            if (user == null || user.isFrozen()) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "User account is frozen or does not exist"));
                continue;
            }

            switch (transaction.getMethod()) {
                case "CARD":
                    processCardTransaction(transaction, user, binMappings, events);
                    break;
                case "TRANSFER":
                    processTransferTransaction(transaction, user, events);
                    break;
                default:
                    events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid transaction method"));
            }
        }
        return events;
    }


    private static void processCardTransaction(Transaction transaction, User user, TreeMap<Long, List<BinMapping>> binMappings, List<Event> events) {
        if (transaction.getAccountNumber().length() < 10) {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Account number too short for card transaction"));
            return;
        }
        long cardPrefix = Long.parseLong(transaction.getAccountNumber().substring(0, 10));
        boolean isValid = false;

        for (List<BinMapping> mappings : binMappings.values()) {
            for (BinMapping mapping : mappings) {
                if (cardPrefix >= mapping.getRangeFrom() && cardPrefix <= mapping.getRangeTo()) {
                    if ("DC".equals(mapping.getType())) {
                        String userCountryISO3 = new Locale("", user.getCountry()).getISO3Country();
                        if (userCountryISO3.equals(mapping.getCountry())) {
                            isValid = true;
                            break;
                        }
                    }
                }
            }
            if (isValid) break;
        }

        if (isValid) {
            processTransactionApproval(transaction, user, events);
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid card BIN or card type"));
        }
    }

    private static void processTransferTransaction(Transaction transaction, User user, List<Event> events) {
        // Track IBANs for deposits
        if ("DEPOSIT".equals(transaction.getType())) {
            userIbans.computeIfAbsent(user.getUserId(), k -> new HashSet<>()).add(transaction.getAccountNumber());
        }

        // Check for withdrawals using only previously used IBANs
        if ("WITHDRAW".equals(transaction.getType())) {
            if (!userIbans.getOrDefault(user.getUserId(), Collections.emptySet()).contains(transaction.getAccountNumber())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Cannot withdraw with a new IBAN " + transaction.getAccountNumber()));
                return;
            }
        }

        // Validate IBAN for transfers
        if (isValidIBAN(transaction.getAccountNumber())) {
            String ibanCountryCode = transaction.getAccountNumber().substring(0, 2);
            if (!ibanCountryCode.equals(user.getCountry())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid account country for IBAN: " + ibanCountryCode + ", expected: " + user.getCountry()));
                return;
            }
            processTransactionApproval(transaction, user, events);
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid IBAN for transfer"));
        }
    }

    private static void processTransactionApproval(Transaction transaction, User user, List<Event> events) {
        String result;
        String message;

        if ("DEPOSIT".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                user.setBalance(user.getBalance() + transaction.getAmount());
                result = "APPROVED";
                message = "OK";
            } else {
                result = "DECLINED";
                message = "Deposit amount out of allowed range";
            }
        } else if ("WITHDRAW".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getWithdrawMin() && transaction.getAmount() <= user.getWithdrawMax()) {
                if (transaction.getAmount() <= user.getBalance()) {
                    user.setBalance(user.getBalance() - transaction.getAmount());
                    result = "APPROVED";
                    message = "OK";
                } else {
                    result = "DECLINED";
                    message = "Withdrawal exceeds balance";
                }
            } else {
                result = "DECLINED";
                message = "Withdrawal amount out of allowed range";
            }
        } else {
            // If the transaction type is neither DEPOSIT nor WITHDRAW
            result = "DECLINED";
            message = "Invalid transaction type";
        }

        // Use the transaction ID directly from the Transaction object
        events.add(new Event(transaction.getTransactionId(), result, message));
    }



    private static void writeBalances(Path filePath, List<User> users, FileWriter logWriter) throws IOException {
        log(logWriter, "Writing balances to: " + filePath);
        try (final FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("userId,balance\n");
            for (final User user : users) {
                writer.append(String.valueOf(user.getUserId()))
                        .append(",").append(String.valueOf(user.getBalance()))
                        .append("\n");
            }
        }
    }

    private static void writeEvents(Path filePath, List<Event> events, FileWriter logWriter) throws IOException {
        log(logWriter, "Writing Events to: " + filePath);
        try (FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("transaction_id,status,message\n");
            for (Event event : events) {
                // Write the event with the original hexadecimal transaction ID
                writer.append(event.getTransactionId())
                        .append(",").append(event.getStatus())
                        .append(",").append(event.getMessage())
                        .append("\n");
            }
        }
    }

    private static void log(FileWriter logWriter, String message) throws IOException {
        System.out.println(message); // Log to console
        logWriter.write(message + "\n"); // Log to file
    }

    public static boolean isValidIBAN(String iban) {
        Map<String, String> ibanPatterns = new HashMap<>();

        // Inserting the full list of IBAN regex patterns
        ibanPatterns.put("AL", "^AL\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("AD", "^AD\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("AT", "^AT\\d{18}$");
        ibanPatterns.put("AZ", "^AZ\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("BH", "^BH\\d{2}[A-Z]{4}[0-9A-Z]{14}$");
        ibanPatterns.put("BE", "^BE\\d{14}$");
        ibanPatterns.put("BA", "^BA\\d{18}$");
        ibanPatterns.put("BR", "^BR\\d{25}[A-Z][0-9A-Z]$");
        ibanPatterns.put("BG", "^BG\\d{2}[A-Z]{4}\\d{6}[0-9A-Z]{8}$");
        ibanPatterns.put("CR", "^CR\\d{20}$");
        ibanPatterns.put("HR", "^HR\\d{19}$");
        ibanPatterns.put("CY", "^CY\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("CZ", "^CZ\\d{22}$");
        ibanPatterns.put("FO", "^FO\\d{16}$");
        ibanPatterns.put("GL", "^GL\\d{16}$");
        ibanPatterns.put("DK", "^DK\\d{16}$");
        ibanPatterns.put("DO", "^DO\\d{2}[0-9A-Z]{4}\\d{20}$");
        ibanPatterns.put("EE", "^EE\\d{18}$");
        ibanPatterns.put("EG", "^EG\\d{27}$");
        ibanPatterns.put("FI", "^FI\\d{16}$");
        ibanPatterns.put("FR", "^FR\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("GE", "^GE\\d{2}[A-Z]{2}\\d{16}$");
        ibanPatterns.put("DE", "^DE\\d{20}$");
        ibanPatterns.put("GI", "^GI\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("GR", "^GR\\d{9}[0-9A-Z]{16}$");
        ibanPatterns.put("GT", "^GT\\d{2}[0-9A-Z]{24}$");
        ibanPatterns.put("HU", "^HU\\d{26}$");
        ibanPatterns.put("IS", "^IS\\d{24}$");
        ibanPatterns.put("IE", "^IE\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("IL", "^IL\\d{21}$");
        ibanPatterns.put("IT", "^IT\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("JO", "^JO\\d{2}[A-Z]{4}\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("KZ", "^KZ\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("XK", "^XK\\d{18}$");
        ibanPatterns.put("KW", "^KW\\d{2}[A-Z]{4}[0-9A-Z]{22}$");
        ibanPatterns.put("LV", "^LV\\d{2}[A-Z]{4}[0-9A-Z]{13}$");
        ibanPatterns.put("LB", "^LB\\d{6}[0-9A-Z]{20}$");
        ibanPatterns.put("LI", "^LI\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("LT", "^LT\\d{18}$");
        ibanPatterns.put("LU", "^LU\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("MK", "^MK\\d{5}[0-9A-Z]{10}\\d{2}$");
        ibanPatterns.put("MT", "^MT\\d{2}[A-Z]{4}\\d{5}[0-9A-Z]{18}$");
        ibanPatterns.put("MR", "^MR\\d{25}$");
        ibanPatterns.put("MU", "^MU\\d{2}[A-Z]{4}\\d{19}[A-Z]{3}$");
        ibanPatterns.put("MD", "^MD\\d{2}[0-9A-Z]{20}$");
        ibanPatterns.put("MC", "^MC\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("ME", "^ME\\d{20}$");
        ibanPatterns.put("NL", "^NL\\d{2}[A-Z]{4}\\d{10}$");
        ibanPatterns.put("NO", "^NO\\d{13}$");
        ibanPatterns.put("PK", "^PK\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("PS", "^PS\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("PL", "^PL\\d{26}$");
        ibanPatterns.put("PT", "^PT\\d{23}$");
        ibanPatterns.put("QA", "^QA\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("RO", "^RO\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("SM", "^SM\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("LC", "^LC\\d{2}[A-Z]{4}[0-9A-Z]{24}$");
        ibanPatterns.put("ST", "^ST\\d{23}$");
        ibanPatterns.put("SA", "^SA\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("RS", "^RS\\d{20}$");
        ibanPatterns.put("SK", "^SK\\d{22}$");
        ibanPatterns.put("SI", "^SI\\d{17}$");
        ibanPatterns.put("ES", "^ES\\d{22}$");
        ibanPatterns.put("SE", "^SE\\d{22}$");
        ibanPatterns.put("CH", "^CH\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("TL", "^TL\\d{21}$");
        ibanPatterns.put("TN", "^TN\\d{22}$");
        ibanPatterns.put("TR", "^TR\\d{7}[0-9A-Z]{17}$");
        ibanPatterns.put("AE", "^AE\\d{21}$");
        ibanPatterns.put("GB", "^GB\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("VA", "^VA\\d{20}$");
        ibanPatterns.put("VG", "^VG\\d{2}[A-Z]{4}\\d{16}$");
        ibanPatterns.put("UA", "^UA\\d{8}[0-9A-Z]{19}$");
        ibanPatterns.put("SC", "^SC\\d{2}[A-Z]{4}\\d{20}[A-Z]{3}$");
        ibanPatterns.put("IQ", "^IQ\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("BY", "^BY\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("SV", "^SV\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("LY", "^LY\\d{23}$");
        ibanPatterns.put("SD", "^SD\\d{16}$");
        ibanPatterns.put("BI", "^BI\\d{2}[0-9A-Z]{10}[0-9A-Z]{12}$");
        ibanPatterns.put("DJ", "^DJ\\d{25}$");
        ibanPatterns.put("RU", "^RU\\d{2}[0-9A-Z]{20}[0-9A-Z]{9}$");

        // Validate IBAN format
        if (iban.length() < 2) return false; // IBAN too short to contain a valid country code
        String countryCode = iban.substring(0, 2);
        String regexPattern = ibanPatterns.get(countryCode);
        return regexPattern != null && iban.matches(regexPattern);
    }
}


class User {
    private String userId;
    private String username;
    private double balance;
    private String country;
    private boolean frozen;
    private double depositMin;
    private double depositMax;
    private double withdrawMin;
    private double withdrawMax;

    // Constructor
    public User(String userId, String username, double balance, String country, boolean frozen, double depositMin, double depositMax, double withdrawMin, double withdrawMax) {
        this.userId = userId;
        this.username = username;
        this.balance = balance;
        this.country = country;
        this.frozen = frozen;
        this.depositMin = depositMin;
        this.depositMax = depositMax;
        this.withdrawMin = withdrawMin;
        this.withdrawMax = withdrawMax;
    }
    // Getters and setters for each field
    public String getUserId() {
        return userId;
    }

    public String getUsername() {
        return username;
    }

    public double getBalance() {
        return balance;
    }

    public String getCountry() {
        return country;
    }

    public boolean isFrozen() {
        return frozen;
    }

    public double getDepositMin() {
        return depositMin;
    }

    public double getDepositMax() {
        return depositMax;
    }

    public double getWithdrawMin() {
        return withdrawMin;
    }

    public double getWithdrawMax() {
        return withdrawMax;
    }

    // Setters
    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public void setFrozen(boolean frozen) {
        this.frozen = frozen;
    }

    public void setDepositMin(double depositMin) {
        this.depositMin = depositMin;
    }

    public void setDepositMax(double depositMax) {
        this.depositMax = depositMax;
    }

    public void setWithdrawMin(double withdrawMin) {
        this.withdrawMin = withdrawMin;
    }

    public void setWithdrawMax(double withdrawMax) {
        this.withdrawMax = withdrawMax;
    }
}

class Transaction {
    private String transactionId;
    private String userId;
    private String type;
    private double amount;
    private String method;
    private String accountNumber;

    public Transaction(String transactionId, String userId, String type, double amount, String method, String accountNumber) {
        // Keep the transaction ID as is, in its original hexadecimal format
        this.transactionId = transactionId;
        this.userId = userId;
        this.type = type;
        this.amount = amount;
        this.method = method;
        this.accountNumber = accountNumber;
    }

    // Getters
    public String getTransactionId() {
        return transactionId;
    }

    public String getUserId() {
        return userId;
    }

    public String getType() {
        return type;
    }

    public double getAmount() {
        return amount;
    }

    public String getMethod() {
        return method;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    // Setters
    public void setTransactionId(String transactionId) {
        this.transactionId = transactionId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }
}

class BinMapping {
    private String name;
    private long rangeFrom;
    private long rangeTo;
    private String type;
    private String country;

    // Constructor
    public BinMapping(String name, long rangeFrom, long rangeTo, String type, String country) {
        this.name = name;
        this.rangeFrom = rangeFrom;
        this.rangeTo = rangeTo;
        this.type = type;
        this.country = country;
    }

    // Getters and setters
    public String getName() {
        return name;
    }

    public long getRangeFrom() {
        return rangeFrom;
    }

    public long getRangeTo() {
        return rangeTo;
    }

    public String getType() {
        return type;
    }

    public String getCountry() {
        return country;
    }

    // Setters
    public void setName(String name) {
        this.name = name;
    }

    public void setRangeFrom(long rangeFrom) {
        this.rangeFrom = rangeFrom;
    }

    public void setRangeTo(long rangeTo) {
        this.rangeTo = rangeTo;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}

class Event {
    String transactionId;
    String status;
    String message;

    public Event(String transactionId, String status, String message) {
        this.transactionId = transactionId;
        this.status = status;
        this.message = message;
    }

    // Getters and Setters
    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}