
Country	Code	SEPA	Length	Account Check	Branch	IBAN Example
Albania	AL	No	28			AL35202111090000000001234567
Andorra	AD	Yes	24			AD1400080001001234567890
Austria	AT	Yes	20			AT483200000012345864
Azerbaijan	AZ	No	28			AZ77VTBA00000000001234567890
Bahrain	BH	No	22			BH02CITI00001077181611
Belgium	BE	Yes	16			BE71096123456769
Bosnia and Herzegovina	BA	No	20			BA393385804800211234
Brazil	BR	No	29			BR1500000000000010932840814P2
Bulgaria	BG	Yes	22			BG18RZBB91550123456789
Costa Rica	CR	No	22			CR23015108410026012345
Croatia	HR	Yes	21			HR1723600001101234565
Cyprus	CY	Yes	28			CY21002001950000357001234567
Czech Republic	CZ	Yes	24			CZ5508000000001234567899
Faroe Islands	FO	No	18			FO9264600123456789
Greenland	GL	No	18			GL8964710123456789
Denmark	DK	Yes	18			DK9520000123456789
Dominican Republic	DO	No	28			DO22ACAU00000000000123456789
Estonia	EE	Yes	20			EE471000001020145685
Egypt	EG	No	29			EG800002000156789012345180002
Finland	FI	Yes	18			FI1410093000123458
France	FR	Yes	27			FR7630006000011234567890189
Georgia	GE	No	22			GE60NB0000000123456789
Germany	DE	Yes	22			DE75512108001245126199
Gibraltar	GI	Yes	23			GI56XAPO000001234567890
Greece	GR	Yes	27			GR9608100010000001234567890
Guatemala	GT	No	28			GT20AGRO00000000001234567890
Hungary	HU	Yes	28			HU93116000060000000012345676
Iceland	IS	Yes	26			IS750001121234563108962099
Ireland	IE	Yes	22			IE64IRCE92050112345678
Israel	IL	No	23			IL170108000000012612345
Italy	IT	Yes	27			IT60X0542811101000000123456
Jordan	JO	No	30			JO71CBJO0000000000001234567890
Kazakhstan	KZ	No	20			KZ244350000012344567
Kosovo	XK	No	20			XK051212012345678906
Kuwait	KW	No	30			KW81CBKU0000000000001234560101
Latvia	LV	Yes	21			LV97HABA0012345678910
Lebanon	LB	No	28			LB92000700000000123123456123
Liechtenstein	LI	Yes	21			LI7408806123456789012
Lithuania	LT	Yes	20			LT601010012345678901
Luxembourg	LU	Yes	20			LU120010001234567891
North Macedonia	MK	No	19			MK07200002785123453
Malta	MT	Yes	31			MT31MALT01100000000000000000123
Mauritania	MR	No	27			MR1300020001010000123456753
Mauritius	MU	No	30			MU43BOMM0101123456789101000MUR
Moldova	MD	No	24			MD21EX000000000001234567
Monaco	MC	Yes	27			MC5810096180790123456789085
Montenegro	ME	No	22			ME25505000012345678951
Netherlands	NL	Yes	18			NL02ABNA0123456789
Norway	NO	Yes	15			NO8330001234567
Pakistan	PK	No	24			PK36SCBL0000001123456702
Palestine	PS	No	29			PS92PALS000000000400123456702
Poland	PL	Yes	28			PL10105000997603123456789123
Portugal	PT	Yes	25			PT50002700000001234567833
Qatar	QA	No	29			QA54QNBA000000000000693123456
Romania	RO	Yes	24			RO66BACX0000001234567890
San Marino	SM	Yes	27			SM76P0854009812123456789123
Saint Lucia	LC	No	32			LC14BOSL123456789012345678901234
Sao Tome and Principe	ST	No	25			ST23000200000289355710148
Saudi Arabia	SA	No	24			SA4420000001234567891234
Serbia	RS	No	22			RS35105008123123123173
Slovak Republic	SK	Yes	24			SK8975000000000012345671
Slovenia	SI	Yes	19			SI56192001234567892
Spain	ES	Yes	24			ES7921000813610123456789
Sweden	SE	Yes	24			SE7280000810340009783242
Switzerland	CH	Yes	21			CH5604835012345678009
Timor-Leste	TL	No	23			TL380010012345678910106
Tunisia	TN	No	24			TN5904018104004942712345
Turkey	TR	No	26			TR320010009999901234567890
United Arab Emirates	AE	No	23			AE460090000000123456789
United Kingdom	GB	Yes	22			GB33BUKB20201555555555
Holy See (the)	VA	Yes	22			VA59001123000012345678
Virgin Islands, British	VG	No	24			VG07ABVI0000000123456789
Ukraine	UA	No	29			UA903052992990004149123456789
Seychelles	SC	No	31			SC74MCBL01031234567890123456USD
Iraq	IQ	No	23			IQ20CBIQ861800101010500
Belarus	BY	No	28			BY86AKBB10100000002966000000
El Salvador	SV	No	28			SV43ACAT00000000000000123123
Libya	LY	No	25			LY38021001000000123456789
Sudan	SD	No	18			SD8811123456789012
Burundi	BI	No	27			BI43220001131012345678912345
Djibouti	DJ	No	27			DJ2110002010010409943020008
Russia	RU	No	33			RU0204452560040702810412345678901


Albania (AL): ^AL\d{10}[0-9A-Z]{16}$
Andorra (AD): ^AD\d{10}[0-9A-Z]{12}$
Austria (AT): ^AT\d{18}$
Azerbaijan (AZ): ^AZ\d{2}[A-Z]{4}[0-9A-Z]{20}$
Bahrain (BH): ^BH\d{2}[A-Z]{4}[0-9A-Z]{14}$
Belgium (BE): ^BE\d{14}$
Bosnia and Herzegovina (BA): ^BA\d{18}$
Brazil (BR): ^BR\d{25}[A-Z][0-9A-Z]$
Bulgaria (BG): ^BG\d{2}[A-Z]{4}\d{6}[0-9A-Z]{8}$
Costa Rica (CR): ^CR\d{20}$
Croatia (HR): ^HR\d{19}$
Cyprus (CY): ^CY\d{10}[0-9A-Z]{16}$
Czech Republic (CZ): ^CZ\d{22}$
Faroe Islands (FO): ^FO\d{16}$
Greenland (GL): ^GL\d{16}$
Denmark (DK): ^DK\d{16}$
Dominican Republic (DO): ^DO\d{2}[0-9A-Z]{4}\d{20}$
Estonia (EE): ^EE\d{18}$
Egypt (EG): ^EG\d{27}$
Finland (FI): ^FI\d{16}$
France (FR): ^FR\d{12}[0-9A-Z]{11}\d{2}$
Georgia (GE): ^GE\d{2}[A-Z]{2}\d{16}$
Germany (DE): ^DE\d{20}$
Gibraltar (GI): ^GI\d{2}[A-Z]{4}[0-9A-Z]{15}$
Greece (GR): ^GR\d{9}[0-9A-Z]{16}$
Guatemala (GT): ^GT\d{2}[0-9A-Z]{24}$
Hungary (HU): ^HU\d{26}$
Iceland (IS): ^IS\d{24}$
Ireland (IE): ^IE\d{2}[A-Z]{4}\d{14}$
Israel (IL): ^IL\d{21}$
Italy (IT): ^IT\d{2}[A-Z]\d{10}[0-9A-Z]{12}$
Jordan (JO): ^JO\d{2}[A-Z]{4}\d{4}[0-9A-Z]{18}$
Kazakhstan (KZ): ^KZ\d{5}[0-9A-Z]{13}$
Kosovo (XK): ^XK\d{18}$
Kuwait (KW): ^KW\d{2}[A-Z]{4}[0-9A-Z]{22}$
Latvia (LV): ^LV\d{2}[A-Z]{4}[0-9A-Z]{13}$
Lebanon (LB): ^LB\d{6}[0-9A-Z]{20}$
Liechtenstein (LI): ^LI\d{7}[0-9A-Z]{12}$
Lithuania (LT): ^LT\d{18}$
Luxembourg (LU): ^LU\d{5}[0-9A-Z]{13}$
North Macedonia (MK): ^MK\d{5}[0-9A-Z]{10}\d{2}$
Malta (MT): ^MT\d{2}[A-Z]{4}\d{5}[0-9A-Z]{18}$
Mauritania (MR): ^MR\d{25}$
Mauritius (MU): ^MU\d{2}[A-Z]{4}\d{19}[A-Z]{3}$
Moldova (MD): ^MD\d{2}[0-9A-Z]{20}$
Monaco (MC): ^MC\d{12}[0-9A-Z]{11}\d{2}$
Montenegro (ME): ^ME\d{20}$
Netherlands (NL): ^NL\d{2}[A-Z]{4}\d{10}$
Norway (NO): ^NO\d{13}$
Pakistan (PK): ^PK\d{2}[A-Z]{4}[0-9A-Z]{16}$
Palestine (PS): ^PS\d{2}[A-Z]{4}[0-9A-Z]{21}$
Poland (PL): ^PL\d{26}$
Portugal (PT): ^PT\d{23}$
Qatar (QA): ^QA\d{2}[A-Z]{4}[0-9A-Z]{21}$
Romania (RO): ^RO\d{2}[A-Z]{4}[0-9A-Z]{16}$
San Marino (SM): ^SM\d{2}[A-Z]\d{10}[0-9A-Z]{12}$
Saint Lucia (LC): ^LC\d{2}[A-Z]{4}[0-9A-Z]{24}$
Sao Tome and Principe (ST): ^ST\d{23}$
Saudi Arabia (SA): ^SA\d{4}[0-9A-Z]{18}$
Serbia (RS): ^RS\d{20}$
Slovak Republic (SK): ^SK\d{22}$
Slovenia (SI): ^SI\d{17}$
Spain (ES): ^ES\d{22}$
Sweden (SE): ^SE\d{22}$
Switzerland (CH): ^CH\d{7}[0-9A-Z]{12}$
Timor-Leste (TL): ^TL\d{21}$
Tunisia (TN): ^TN\d{22}$
Turkey (TR): ^TR\d{7}[0-9A-Z]{17}$
United Arab Emirates (AE): ^AE\d{21}$
United Kingdom (GB): ^GB\d{2}[A-Z]{4}\d{14}$
Holy See (VA): ^VA\d{20}$
Virgin Islands, British (VG): ^VG\d{2}[A-Z]{4}\d{16}$
Ukraine (UA): ^UA\d{8}[0-9A-Z]{19}$
Seychelles (SC): ^SC\d{2}[A-Z]{4}\d{20}[A-Z]{3}$
Iraq (IQ): ^IQ\d{2}[A-Z]{4}[0-9A-Z]{15}$
Belarus (BY): ^BY\d{2}[A-Z]{4}[0-9A-Z]{20}$
El Salvador (SV): ^SV\d{2}[A-Z]{4}[0-9A-Z]{20}$
Libya (LY): ^LY\d{23}$
Sudan (SD): ^SD\d{16}$
Burundi (BI): ^BI\d{2}[0-9A-Z]{10}[0-9A-Z]{12}$
Djibouti (DJ): ^DJ\d{25}$
Russia (RU): ^RU\d{2}[0-9A-Z]{20}[0-9A-Z]{9}$



package com.playtech.assignment;

 import java.io.BufferedReader;
 import java.io.FileWriter;
 import java.io.IOException;
 import java.math.BigInteger;
 import java.nio.file.Files;
 import java.nio.file.Path;
 import java.nio.file.Paths;
 import java.util.*;
 import java.util.stream.Collectors;


 // This template shows input parameters format.
 // It is otherwise not mandatory to use, you can write everything from scratch if you wish.
 public class TransactionProcessorSample {
     // Global variables to track IBANs used for deposits and account number usage
     static Map<String, Set<String>> userIbans = new HashMap<>();
     static Map<String, String> accountUsers = new HashMap<>();

     public static void main(final String[] args) throws IOException {
         List<User> users = TransactionProcessorSample.readUsers(Paths.get(args[0]));
         List<Transaction> transactions = TransactionProcessorSample.readTransactions(Paths.get(args[1]));
         TreeMap<Long, List<BinMapping>> binMappings = TransactionProcessorSample.readBinMappings(Paths.get(args[2]));

         List<Event> events = TransactionProcessorSample.processTransactions(users, transactions, binMappings);

         TransactionProcessorSample.writeBalances(Paths.get(args[3]), users);
         TransactionProcessorSample.writeEvents(Paths.get(args[4]), events);
     }



     private static List<User> readUsers(final Path filePath) {
         List<User> users = new ArrayList<>();
         try (BufferedReader br = Files.newBufferedReader(filePath)) {
             String line;
             boolean isFirstLine = true; // Flag to check if it's the first line (header)

             while ((line = br.readLine()) != null) {
                 // Skip the first line which is expected to be the header
                 if (isFirstLine) {
                     isFirstLine = false;
                     continue;
                 }

                 String[] attributes = line.split(",");
                 User user = createUser(attributes);
                 users.add(user);
             }
         } catch (IOException ioe) {
             ioe.printStackTrace();
         }
         return users;
     }

     private static User createUser(String[] metadata) {
         String userId = metadata[0]; // No need to parse as int
         String username = metadata[1];
         double balance = Double.parseDouble(metadata[2]);
         String country = metadata[3];
         boolean frozen = Boolean.parseBoolean(metadata[4]);
         double depositMin = Double.parseDouble(metadata[5]);
         double depositMax = Double.parseDouble(metadata[6]);
         double withdrawMin = Double.parseDouble(metadata[7]);
         double withdrawMax = Double.parseDouble(metadata[8]);
         return new User(userId, username, balance, country, frozen, depositMin, depositMax, withdrawMin, withdrawMax);
     }

     private static List<Transaction> readTransactions(final Path filePath) {
         List<Transaction> transactions = new ArrayList<>();
         try (BufferedReader br = Files.newBufferedReader(filePath)) {
             String line;
             boolean isFirstLine = true; // Flag to check if it's the first line (header)

             while ((line = br.readLine()) != null) {
                 // Skip the first line which is expected to be the header
                 if (isFirstLine) {
                     isFirstLine = false;
                     continue;
                 }

                 String[] attributes = line.split(",");
                 Transaction transaction = createTransaction(attributes);
                 transactions.add(transaction);
             }
         } catch (IOException ioe) {
             ioe.printStackTrace();
         }
         return transactions;
     }

     private static Transaction createTransaction(String[] metadata) {
         String transactionId = metadata[0];
         String userId = metadata[1]; // Treat as String, no need for Integer.parseInt()
         String type = metadata[2];
         double amount = Double.parseDouble(metadata[3]);
         String method = metadata[4];
         String accountNumber = metadata[5];
         return new Transaction(transactionId, userId, type, amount, method, accountNumber);
     }

     private static TreeMap<Long, List<BinMapping>> readBinMappings(final Path filePath) {
         TreeMap<Long, List<BinMapping>> binMappings = new TreeMap<>();
         try (BufferedReader br = Files.newBufferedReader(filePath)) {
             String line;
             boolean isFirstLine = true;

             while ((line = br.readLine()) != null) {
                 if (isFirstLine) {
                     isFirstLine = false;
                     continue;
                 }

                 String[] attributes = line.split(",");
                 BinMapping binMapping = createBinMapping(attributes);
                 binMappings.computeIfAbsent(binMapping.getRangeFrom(), k -> new ArrayList<>()).add(binMapping);
             }
         } catch (IOException ioe) {
             ioe.printStackTrace();
         }
         return binMappings;
     }

     private static BinMapping createBinMapping(String[] metadata) {
         String name = metadata[0];
         long rangeFrom = Long.parseLong(metadata[1]); // Parse as long
         long rangeTo = Long.parseLong(metadata[2]);   // Parse as long
         String type = metadata[3];
         String country = metadata[4];
         return new BinMapping(name, rangeFrom, rangeTo, type, country);
     }




     private static List<Event> processTransactions(final List<User> users, final List<Transaction> transactions, TreeMap<Long, List<BinMapping>> binMappings) {
         List<Event> events = new ArrayList<>();
         Map<String, User> usersMap = users.stream().collect(Collectors.toMap(User::getUserId, user -> user));
         Set<String> processedTransactionIds = new HashSet<>();

         for (Transaction transaction : transactions) {
             // Check for previously processed transaction IDs
             if (!processedTransactionIds.add(transaction.getTransactionId())) {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Transaction ID already processed"));
                 continue;
             }

             // Check for account number usage by other users
             if (accountUsers.containsKey(transaction.getAccountNumber()) && !accountUsers.get(transaction.getAccountNumber()).equals(transaction.getUserId())) {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Account " + transaction.getAccountNumber() + " is in use by other user"));
                 continue;
             } else {
                 accountUsers.put(transaction.getAccountNumber(), transaction.getUserId());
             }

             User user = usersMap.get(transaction.getUserId());
             if (user == null || user.isFrozen()) {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "User account is frozen or does not exist"));
                 continue;
             }

             switch (transaction.getMethod()) {
                 case "CARD":
                     processCardTransaction(transaction, user, binMappings, events);
                     break;
                 case "TRANSFER":
                     processTransferTransaction(transaction, user, events);
                     break;
                 default:
                     events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid transaction method"));
             }
         }
         return events;
     }

     private static void processCardTransaction(Transaction transaction, User user, TreeMap<Long, List<BinMapping>> binMappings, List<Event> events) {

         long cardPrefix = Long.parseLong(transaction.getAccountNumber().substring(0, 10)); // Use first 10 digits
         boolean isValid = false;

         for (List<BinMapping> mappings : binMappings.values()) {
             for (BinMapping mapping : mappings) {
                 if (cardPrefix >= mapping.getRangeFrom() && cardPrefix <= mapping.getRangeTo()) {
                     if ("DC".equals(mapping.getType())) {
                         // Convert user's two-letter country code to three-letter code for comparison
                         String userCountryISO3 = new Locale("", user.getCountry()).getISO3Country();
                         if (userCountryISO3.equals(mapping.getCountry())) {
                             isValid = true;
                             break;
                         }
                     }
                 }
             }
             if (isValid) break;
         }

         if (isValid) {
             processTransactionApproval(transaction, user, events);
         } else {
             events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid card BIN or card type"));
         }
     }

     private static void processTransferTransaction(Transaction transaction, User user, List<Event> events) {
         // Track IBANs for deposits
         if ("DEPOSIT".equals(transaction.getType())) {
             userIbans.computeIfAbsent(user.getUserId(), k -> new HashSet<>()).add(transaction.getAccountNumber());
         }

         // Check for withdrawals using only previously used IBANs
         if ("WITHDRAW".equals(transaction.getType())) {
             if (!userIbans.getOrDefault(user.getUserId(), Collections.emptySet()).contains(transaction.getAccountNumber())) {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Cannot withdraw with a new IBAN " + transaction.getAccountNumber()));
                 return;
             }
         }

         // Validate IBAN for transfers
         if (isValidIBAN(transaction.getAccountNumber())) {
             String ibanCountryCode = transaction.getAccountNumber().substring(0, 2);
             if (!ibanCountryCode.equals(user.getCountry())) {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid account country for IBAN: " + ibanCountryCode + ", expected: " + user.getCountry()));
                 return;
             }
             processTransactionApproval(transaction, user, events);
         } else {
             events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid IBAN for transfer"));
         }
     }

     private static void processTransactionApproval(Transaction transaction, User user, List<Event> events) {
         if ("DEPOSIT".equals(transaction.getType())) {
             if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                 user.setBalance(user.getBalance() + transaction.getAmount());
                 events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
             } else {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Deposit amount out of allowed range"));
             }
         } else if ("WITHDRAW".equals(transaction.getType())) {
             if (transaction.getAmount() >= user.getWithdrawMin() && transaction.getAmount() <= user.getWithdrawMax()) {
                 if (transaction.getAmount() <= user.getBalance()) {
                     user.setBalance(user.getBalance() - transaction.getAmount());
                     events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
                 } else {
                     events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal exceeds balance"));
                 }
             } else {
                 events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal amount out of allowed range"));
             }
         }
     }



     private static void writeBalances(final Path filePath, final List<User> users) throws IOException {
         try (final FileWriter writer = new FileWriter(filePath.toFile(), false)) {
             writer.append("userId,balance\n");
             for (final User user : users) {
                 writer.append(String.valueOf(user.getUserId()))
                         .append(",").append(String.valueOf(user.getBalance()))
                         .append("\n");
             }
         }
     }

     private static void writeEvents(Path filePath, List<Event> events) throws IOException {
         try (FileWriter writer = new FileWriter(filePath.toFile(), false)) {
             writer.append("transaction_id,status,message\n");
             for (Event event : events) {
                 writer.append(event.getTransactionId())
                         .append(",").append(event.getStatus())
                         .append(",").append(event.getMessage())
                         .append("\n");
             }
         }
     }

     public static boolean isValidIBAN(String iban) {
         Map<String, String> ibanPatterns = new HashMap<>();

         // Inserting the full list of IBAN regex patterns
         ibanPatterns.put("AL", "^AL\\d{10}[0-9A-Z]{16}$");
         ibanPatterns.put("AD", "^AD\\d{10}[0-9A-Z]{12}$");
         ibanPatterns.put("AT", "^AT\\d{18}$");
         ibanPatterns.put("AZ", "^AZ\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
         ibanPatterns.put("BH", "^BH\\d{2}[A-Z]{4}[0-9A-Z]{14}$");
         ibanPatterns.put("BE", "^BE\\d{14}$");
         ibanPatterns.put("BA", "^BA\\d{18}$");
         ibanPatterns.put("BR", "^BR\\d{25}[A-Z][0-9A-Z]$");
         ibanPatterns.put("BG", "^BG\\d{2}[A-Z]{4}\\d{6}[0-9A-Z]{8}$");
         ibanPatterns.put("CR", "^CR\\d{20}$");
         ibanPatterns.put("HR", "^HR\\d{19}$");
         ibanPatterns.put("CY", "^CY\\d{10}[0-9A-Z]{16}$");
         ibanPatterns.put("CZ", "^CZ\\d{22}$");
         ibanPatterns.put("FO", "^FO\\d{16}$");
         ibanPatterns.put("GL", "^GL\\d{16}$");
         ibanPatterns.put("DK", "^DK\\d{16}$");
         ibanPatterns.put("DO", "^DO\\d{2}[0-9A-Z]{4}\\d{20}$");
         ibanPatterns.put("EE", "^EE\\d{18}$");
         ibanPatterns.put("EG", "^EG\\d{27}$");
         ibanPatterns.put("FI", "^FI\\d{16}$");
         ibanPatterns.put("FR", "^FR\\d{12}[0-9A-Z]{11}\\d{2}$");
         ibanPatterns.put("GE", "^GE\\d{2}[A-Z]{2}\\d{16}$");
         ibanPatterns.put("DE", "^DE\\d{20}$");
         ibanPatterns.put("GI", "^GI\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
         ibanPatterns.put("GR", "^GR\\d{9}[0-9A-Z]{16}$");
         ibanPatterns.put("GT", "^GT\\d{2}[0-9A-Z]{24}$");
         ibanPatterns.put("HU", "^HU\\d{26}$");
         ibanPatterns.put("IS", "^IS\\d{24}$");
         ibanPatterns.put("IE", "^IE\\d{2}[A-Z]{4}\\d{14}$");
         ibanPatterns.put("IL", "^IL\\d{21}$");
         ibanPatterns.put("IT", "^IT\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
         ibanPatterns.put("JO", "^JO\\d{2}[A-Z]{4}\\d{4}[0-9A-Z]{18}$");
         ibanPatterns.put("KZ", "^KZ\\d{5}[0-9A-Z]{13}$");
         ibanPatterns.put("XK", "^XK\\d{18}$");
         ibanPatterns.put("KW", "^KW\\d{2}[A-Z]{4}[0-9A-Z]{22}$");
         ibanPatterns.put("LV", "^LV\\d{2}[A-Z]{4}[0-9A-Z]{13}$");
         ibanPatterns.put("LB", "^LB\\d{6}[0-9A-Z]{20}$");
         ibanPatterns.put("LI", "^LI\\d{7}[0-9A-Z]{12}$");
         ibanPatterns.put("LT", "^LT\\d{18}$");
         ibanPatterns.put("LU", "^LU\\d{5}[0-9A-Z]{13}$");
         ibanPatterns.put("MK", "^MK\\d{5}[0-9A-Z]{10}\\d{2}$");
         ibanPatterns.put("MT", "^MT\\d{2}[A-Z]{4}\\d{5}[0-9A-Z]{18}$");
         ibanPatterns.put("MR", "^MR\\d{25}$");
         ibanPatterns.put("MU", "^MU\\d{2}[A-Z]{4}\\d{19}[A-Z]{3}$");
         ibanPatterns.put("MD", "^MD\\d{2}[0-9A-Z]{20}$");
         ibanPatterns.put("MC", "^MC\\d{12}[0-9A-Z]{11}\\d{2}$");
         ibanPatterns.put("ME", "^ME\\d{20}$");
         ibanPatterns.put("NL", "^NL\\d{2}[A-Z]{4}\\d{10}$");
         ibanPatterns.put("NO", "^NO\\d{13}$");
         ibanPatterns.put("PK", "^PK\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
         ibanPatterns.put("PS", "^PS\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
         ibanPatterns.put("PL", "^PL\\d{26}$");
         ibanPatterns.put("PT", "^PT\\d{23}$");
         ibanPatterns.put("QA", "^QA\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
         ibanPatterns.put("RO", "^RO\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
         ibanPatterns.put("SM", "^SM\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
         ibanPatterns.put("LC", "^LC\\d{2}[A-Z]{4}[0-9A-Z]{24}$");
         ibanPatterns.put("ST", "^ST\\d{23}$");
         ibanPatterns.put("SA", "^SA\\d{4}[0-9A-Z]{18}$");
         ibanPatterns.put("RS", "^RS\\d{20}$");
         ibanPatterns.put("SK", "^SK\\d{22}$");
         ibanPatterns.put("SI", "^SI\\d{17}$");
         ibanPatterns.put("ES", "^ES\\d{22}$");
         ibanPatterns.put("SE", "^SE\\d{22}$");
         ibanPatterns.put("CH", "^CH\\d{7}[0-9A-Z]{12}$");
         ibanPatterns.put("TL", "^TL\\d{21}$");
         ibanPatterns.put("TN", "^TN\\d{22}$");
         ibanPatterns.put("TR", "^TR\\d{7}[0-9A-Z]{17}$");
         ibanPatterns.put("AE", "^AE\\d{21}$");
         ibanPatterns.put("GB", "^GB\\d{2}[A-Z]{4}\\d{14}$");
         ibanPatterns.put("VA", "^VA\\d{20}$");
         ibanPatterns.put("VG", "^VG\\d{2}[A-Z]{4}\\d{16}$");
         ibanPatterns.put("UA", "^UA\\d{8}[0-9A-Z]{19}$");
         ibanPatterns.put("SC", "^SC\\d{2}[A-Z]{4}\\d{20}[A-Z]{3}$");
         ibanPatterns.put("IQ", "^IQ\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
         ibanPatterns.put("BY", "^BY\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
         ibanPatterns.put("SV", "^SV\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
         ibanPatterns.put("LY", "^LY\\d{23}$");
         ibanPatterns.put("SD", "^SD\\d{16}$");
         ibanPatterns.put("BI", "^BI\\d{2}[0-9A-Z]{10}[0-9A-Z]{12}$");
         ibanPatterns.put("DJ", "^DJ\\d{25}$");
         ibanPatterns.put("RU", "^RU\\d{2}[0-9A-Z]{20}[0-9A-Z]{9}$");

         // Validate IBAN format
         if (iban.length() < 2) return false; // IBAN too short to contain a valid country code
         String countryCode = iban.substring(0, 2);
         String regexPattern = ibanPatterns.get(countryCode);
         return regexPattern != null && iban.matches(regexPattern);
     }
 }


 class User {
     private String userId;
     private String username;
     private double balance;
     private String country;
     private boolean frozen;
     private double depositMin;
     private double depositMax;
     private double withdrawMin;
     private double withdrawMax;

     // Constructor
     public User(String userId, String username, double balance, String country, boolean frozen, double depositMin, double depositMax, double withdrawMin, double withdrawMax) {
         this.userId = userId;
         this.username = username;
         this.balance = balance;
         this.country = country;
         this.frozen = frozen;
         this.depositMin = depositMin;
         this.depositMax = depositMax;
         this.withdrawMin = withdrawMin;
         this.withdrawMax = withdrawMax;
     }
     // Getters and setters for each field
     public String getUserId() {
         return userId;
     }

     public String getUsername() {
         return username;
     }

     public double getBalance() {
         return balance;
     }

     public String getCountry() {
         return country;
     }

     public boolean isFrozen() {
         return frozen;
     }

     public double getDepositMin() {
         return depositMin;
     }

     public double getDepositMax() {
         return depositMax;
     }

     public double getWithdrawMin() {
         return withdrawMin;
     }

     public double getWithdrawMax() {
         return withdrawMax;
     }

     // Setters
     public void setUserId(String userId) {
         this.userId = userId;
     }

     public void setUsername(String username) {
         this.username = username;
     }

     public void setBalance(double balance) {
         this.balance = balance;
     }

     public void setCountry(String country) {
         this.country = country;
     }

     public void setFrozen(boolean frozen) {
         this.frozen = frozen;
     }

     public void setDepositMin(double depositMin) {
         this.depositMin = depositMin;
     }

     public void setDepositMax(double depositMax) {
         this.depositMax = depositMax;
     }

     public void setWithdrawMin(double withdrawMin) {
         this.withdrawMin = withdrawMin;
     }

     public void setWithdrawMax(double withdrawMax) {
         this.withdrawMax = withdrawMax;
     }
 }

 class Transaction {
     private String transactionId;
     private String userId;
     private String type;
     private double amount;
     private String method;
     private String accountNumber;

     // Adjusted constructor
     public Transaction(String transactionId, String userId, String type, double amount, String method, String accountNumber) {
         this.transactionId = transactionId;
         this.userId = userId;
         this.type = type;
         this.amount = amount;
         this.method = method;
         this.accountNumber = accountNumber;
     }

     // Getters
     public String getTransactionId() {
         return transactionId;
     }

     public String getUserId() {
         return userId;
     }

     public String getType() {
         return type;
     }

     public double getAmount() {
         return amount;
     }

     public String getMethod() {
         return method;
     }

     public String getAccountNumber() {
         return accountNumber;
     }

     // Setters
     public void setTransactionId(String transactionId) {
         this.transactionId = transactionId;
     }

     public void setUserId(String userId) {
         this.userId = userId;
     }

     public void setType(String type) {
         this.type = type;
     }

     public void setAmount(double amount) {
         this.amount = amount;
     }

     public void setMethod(String method) {
         this.method = method;
     }

     public void setAccountNumber(String accountNumber) {
         this.accountNumber = accountNumber;
     }
 }

 class BinMapping {
     private String name;
     private long rangeFrom;
     private long rangeTo;
     private String type;
     private String country;

     // Constructor
     public BinMapping(String name, long rangeFrom, long rangeTo, String type, String country) {
         this.name = name;
         this.rangeFrom = rangeFrom;
         this.rangeTo = rangeTo;
         this.type = type;
         this.country = country;
     }

     // Getters and setters
     public String getName() {
         return name;
     }

     public long getRangeFrom() {
         return rangeFrom;
     }

     public long getRangeTo() {
         return rangeTo;
     }

     public String getType() {
         return type;
     }

     public String getCountry() {
         return country;
     }

     // Setters
     public void setName(String name) {
         this.name = name;
     }

     public void setRangeFrom(long rangeFrom) {
         this.rangeFrom = rangeFrom;
     }

     public void setRangeTo(long rangeTo) {
         this.rangeTo = rangeTo;
     }

     public void setType(String type) {
         this.type = type;
     }

     public void setCountry(String country) {
         this.country = country;
     }
 }

 class Event {
     String transactionId;
     String status;
     String message;

     public Event(String transactionId, String status, String message) {
         this.transactionId = transactionId;
         this.status = status;
         this.message = message;
     }

     // Getters and Setters
     public String getTransactionId() { return transactionId; }
     public void setTransactionId(String transactionId) { this.transactionId = transactionId; }

     public String getStatus() { return status; }
     public void setStatus(String status) { this.status = status; }

     public String getMessage() { return message; }
     public void setMessage(String message) { this.message = message; }
 }


# 2

package com.playtech.assignment;

import java.io.BufferedReader;
import java.io.FileWriter;
import java.io.IOException;
import java.math.BigInteger;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.*;
import java.util.stream.Collectors;


// This template shows input parameters format.
// It is otherwise not mandatory to use, you can write everything from scratch if you wish.
public class TransactionProcessorSample {
    // Global variables to track IBANs used for deposits and account number usage
    static Map<String, Set<String>> userIbans = new HashMap<>();
    static Map<String, String> accountUsers = new HashMap<>();

    public static void main(final String[] args) throws IOException {
        List<User> users = TransactionProcessorSample.readUsers(Paths.get(args[0]));
        List<Transaction> transactions = TransactionProcessorSample.readTransactions(Paths.get(args[1]));
        TreeMap<Long, List<BinMapping>> binMappings = TransactionProcessorSample.readBinMappings(Paths.get(args[2]));

        List<Event> events = TransactionProcessorSample.processTransactions(users, transactions, binMappings);

        TransactionProcessorSample.writeBalances(Paths.get(args[3]), users);
        TransactionProcessorSample.writeEvents(Paths.get(args[4]), events);
    }



    private static List<User> readUsers(final Path filePath) {
        List<User> users = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                User user = createUser(attributes);
                users.add(user);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return users;
    }

    private static User createUser(String[] metadata) {
        String userId = metadata[0]; // No need to parse as int
        String username = metadata[1];
        double balance = Double.parseDouble(metadata[2]);
        String country = metadata[3];
        boolean frozen = Boolean.parseBoolean(metadata[4]);
        double depositMin = Double.parseDouble(metadata[5]);
        double depositMax = Double.parseDouble(metadata[6]);
        double withdrawMin = Double.parseDouble(metadata[7]);
        double withdrawMax = Double.parseDouble(metadata[8]);
        return new User(userId, username, balance, country, frozen, depositMin, depositMax, withdrawMin, withdrawMax);
    }

    private static List<Transaction> readTransactions(final Path filePath) {
        List<Transaction> transactions = new ArrayList<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true; // Flag to check if it's the first line (header)

            while ((line = br.readLine()) != null) {
                // Skip the first line which is expected to be the header
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                Transaction transaction = createTransaction(attributes);
                transactions.add(transaction);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return transactions;
    }

    private static Transaction createTransaction(String[] metadata) {
        String transactionId = metadata[0];
        String userId = metadata[1]; // Treat as String, no need for Integer.parseInt()
        String type = metadata[2];
        double amount = Double.parseDouble(metadata[3]);
        String method = metadata[4];
        String accountNumber = metadata[5];
        return new Transaction(transactionId, userId, type, amount, method, accountNumber);
    }

    private static TreeMap<Long, List<BinMapping>> readBinMappings(final Path filePath) {
        TreeMap<Long, List<BinMapping>> binMappings = new TreeMap<>();
        try (BufferedReader br = Files.newBufferedReader(filePath)) {
            String line;
            boolean isFirstLine = true;

            while ((line = br.readLine()) != null) {
                if (isFirstLine) {
                    isFirstLine = false;
                    continue;
                }

                String[] attributes = line.split(",");
                BinMapping binMapping = createBinMapping(attributes);
                binMappings.computeIfAbsent(binMapping.getRangeFrom(), k -> new ArrayList<>()).add(binMapping);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
        return binMappings;
    }

    private static BinMapping createBinMapping(String[] metadata) {
        String name = metadata[0];
        long rangeFrom = Long.parseLong(metadata[1]); // Parse as long
        long rangeTo = Long.parseLong(metadata[2]);   // Parse as long
        String type = metadata[3];
        String country = metadata[4];
        return new BinMapping(name, rangeFrom, rangeTo, type, country);
    }




    private static List<Event> processTransactions(final List<User> users, final List<Transaction> transactions, TreeMap<Long, List<BinMapping>> binMappings) {
        List<Event> events = new ArrayList<>();
        Map<String, User> usersMap = users.stream().collect(Collectors.toMap(User::getUserId, user -> user));
        Set<String> processedTransactionIds = new HashSet<>();

        for (Transaction transaction : transactions) {
            // Check for previously processed transaction IDs
            if (!processedTransactionIds.add(transaction.getTransactionId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Transaction ID already processed"));
                continue;
            }

            // Check for account number usage by other users
            if (accountUsers.containsKey(transaction.getAccountNumber()) && !accountUsers.get(transaction.getAccountNumber()).equals(transaction.getUserId())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Account " + transaction.getAccountNumber() + " is in use by other user"));
                continue;
            } else {
                accountUsers.put(transaction.getAccountNumber(), transaction.getUserId());
            }

            User user = usersMap.get(transaction.getUserId());
            if (user == null || user.isFrozen()) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "User account is frozen or does not exist"));
                continue;
            }

            switch (transaction.getMethod()) {
                case "CARD":
                    processCardTransaction(transaction, user, binMappings, events);
                    break;
                case "TRANSFER":
                    processTransferTransaction(transaction, user, events);
                    break;
                default:
                    events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid transaction method"));
            }
        }
        return events;
    }

    private static void processCardTransaction(Transaction transaction, User user, TreeMap<Long, List<BinMapping>> binMappings, List<Event> events) {

        long cardPrefix = Long.parseLong(transaction.getAccountNumber().substring(0, 10)); // Use first 10 digits
        boolean isValid = false;

        for (List<BinMapping> mappings : binMappings.values()) {
            for (BinMapping mapping : mappings) {
                if (cardPrefix >= mapping.getRangeFrom() && cardPrefix <= mapping.getRangeTo()) {
                    if ("DC".equals(mapping.getType())) {
                        // Convert user's two-letter country code to three-letter code for comparison
                        String userCountryISO3 = new Locale("", user.getCountry()).getISO3Country();
                        if (userCountryISO3.equals(mapping.getCountry())) {
                            isValid = true;
                            break;
                        }
                    }
                }
            }
            if (isValid) break;
        }

        if (isValid) {
            processTransactionApproval(transaction, user, events);
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid card BIN or card type"));
        }
    }

    private static void processTransferTransaction(Transaction transaction, User user, List<Event> events) {
        // Track IBANs for deposits
        if ("DEPOSIT".equals(transaction.getType())) {
            userIbans.computeIfAbsent(user.getUserId(), k -> new HashSet<>()).add(transaction.getAccountNumber());
        }

        // Check for withdrawals using only previously used IBANs
        if ("WITHDRAW".equals(transaction.getType())) {
            if (!userIbans.getOrDefault(user.getUserId(), Collections.emptySet()).contains(transaction.getAccountNumber())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Cannot withdraw with a new IBAN " + transaction.getAccountNumber()));
                return;
            }
        }

        // Validate IBAN for transfers
        if (isValidIBAN(transaction.getAccountNumber())) {
            String ibanCountryCode = transaction.getAccountNumber().substring(0, 2);
            if (!ibanCountryCode.equals(user.getCountry())) {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid account country for IBAN: " + ibanCountryCode + ", expected: " + user.getCountry()));
                return;
            }
            processTransactionApproval(transaction, user, events);
        } else {
            events.add(new Event(transaction.getTransactionId(), "DECLINED", "Invalid IBAN for transfer"));
        }
    }

    private static void processTransactionApproval(Transaction transaction, User user, List<Event> events) {
        if ("DEPOSIT".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getDepositMin() && transaction.getAmount() <= user.getDepositMax()) {
                user.setBalance(user.getBalance() + transaction.getAmount());
                events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
            } else {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Deposit amount out of allowed range"));
            }
        } else if ("WITHDRAW".equals(transaction.getType())) {
            if (transaction.getAmount() >= user.getWithdrawMin() && transaction.getAmount() <= user.getWithdrawMax()) {
                if (transaction.getAmount() <= user.getBalance()) {
                    user.setBalance(user.getBalance() - transaction.getAmount());
                    events.add(new Event(transaction.getTransactionId(), "APPROVED", "OK"));
                } else {
                    events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal exceeds balance"));
                }
            } else {
                events.add(new Event(transaction.getTransactionId(), "DECLINED", "Withdrawal amount out of allowed range"));
            }
        }
    }



    private static void writeBalances(final Path filePath, final List<User> users) throws IOException {
        try (final FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("userId,balance\n");
            for (final User user : users) {
                writer.append(String.valueOf(user.getUserId()))
                        .append(",").append(String.valueOf(user.getBalance()))
                        .append("\n");
            }
        }
    }

    private static void writeEvents(Path filePath, List<Event> events) throws IOException {
        try (FileWriter writer = new FileWriter(filePath.toFile(), false)) {
            writer.append("transaction_id,status,message\n");
            for (Event event : events) {
                writer.append(event.getTransactionId())
                        .append(",").append(event.getStatus())
                        .append(",").append(event.getMessage())
                        .append("\n");
            }
        }
    }

    public static boolean isValidIBAN(String iban) {
        Map<String, String> ibanPatterns = new HashMap<>();

        // Inserting the full list of IBAN regex patterns
        ibanPatterns.put("AL", "^AL\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("AD", "^AD\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("AT", "^AT\\d{18}$");
        ibanPatterns.put("AZ", "^AZ\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("BH", "^BH\\d{2}[A-Z]{4}[0-9A-Z]{14}$");
        ibanPatterns.put("BE", "^BE\\d{14}$");
        ibanPatterns.put("BA", "^BA\\d{18}$");
        ibanPatterns.put("BR", "^BR\\d{25}[A-Z][0-9A-Z]$");
        ibanPatterns.put("BG", "^BG\\d{2}[A-Z]{4}\\d{6}[0-9A-Z]{8}$");
        ibanPatterns.put("CR", "^CR\\d{20}$");
        ibanPatterns.put("HR", "^HR\\d{19}$");
        ibanPatterns.put("CY", "^CY\\d{10}[0-9A-Z]{16}$");
        ibanPatterns.put("CZ", "^CZ\\d{22}$");
        ibanPatterns.put("FO", "^FO\\d{16}$");
        ibanPatterns.put("GL", "^GL\\d{16}$");
        ibanPatterns.put("DK", "^DK\\d{16}$");
        ibanPatterns.put("DO", "^DO\\d{2}[0-9A-Z]{4}\\d{20}$");
        ibanPatterns.put("EE", "^EE\\d{18}$");
        ibanPatterns.put("EG", "^EG\\d{27}$");
        ibanPatterns.put("FI", "^FI\\d{16}$");
        ibanPatterns.put("FR", "^FR\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("GE", "^GE\\d{2}[A-Z]{2}\\d{16}$");
        ibanPatterns.put("DE", "^DE\\d{20}$");
        ibanPatterns.put("GI", "^GI\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("GR", "^GR\\d{9}[0-9A-Z]{16}$");
        ibanPatterns.put("GT", "^GT\\d{2}[0-9A-Z]{24}$");
        ibanPatterns.put("HU", "^HU\\d{26}$");
        ibanPatterns.put("IS", "^IS\\d{24}$");
        ibanPatterns.put("IE", "^IE\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("IL", "^IL\\d{21}$");
        ibanPatterns.put("IT", "^IT\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("JO", "^JO\\d{2}[A-Z]{4}\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("KZ", "^KZ\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("XK", "^XK\\d{18}$");
        ibanPatterns.put("KW", "^KW\\d{2}[A-Z]{4}[0-9A-Z]{22}$");
        ibanPatterns.put("LV", "^LV\\d{2}[A-Z]{4}[0-9A-Z]{13}$");
        ibanPatterns.put("LB", "^LB\\d{6}[0-9A-Z]{20}$");
        ibanPatterns.put("LI", "^LI\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("LT", "^LT\\d{18}$");
        ibanPatterns.put("LU", "^LU\\d{5}[0-9A-Z]{13}$");
        ibanPatterns.put("MK", "^MK\\d{5}[0-9A-Z]{10}\\d{2}$");
        ibanPatterns.put("MT", "^MT\\d{2}[A-Z]{4}\\d{5}[0-9A-Z]{18}$");
        ibanPatterns.put("MR", "^MR\\d{25}$");
        ibanPatterns.put("MU", "^MU\\d{2}[A-Z]{4}\\d{19}[A-Z]{3}$");
        ibanPatterns.put("MD", "^MD\\d{2}[0-9A-Z]{20}$");
        ibanPatterns.put("MC", "^MC\\d{12}[0-9A-Z]{11}\\d{2}$");
        ibanPatterns.put("ME", "^ME\\d{20}$");
        ibanPatterns.put("NL", "^NL\\d{2}[A-Z]{4}\\d{10}$");
        ibanPatterns.put("NO", "^NO\\d{13}$");
        ibanPatterns.put("PK", "^PK\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("PS", "^PS\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("PL", "^PL\\d{26}$");
        ibanPatterns.put("PT", "^PT\\d{23}$");
        ibanPatterns.put("QA", "^QA\\d{2}[A-Z]{4}[0-9A-Z]{21}$");
        ibanPatterns.put("RO", "^RO\\d{2}[A-Z]{4}[0-9A-Z]{16}$");
        ibanPatterns.put("SM", "^SM\\d{2}[A-Z]\\d{10}[0-9A-Z]{12}$");
        ibanPatterns.put("LC", "^LC\\d{2}[A-Z]{4}[0-9A-Z]{24}$");
        ibanPatterns.put("ST", "^ST\\d{23}$");
        ibanPatterns.put("SA", "^SA\\d{4}[0-9A-Z]{18}$");
        ibanPatterns.put("RS", "^RS\\d{20}$");
        ibanPatterns.put("SK", "^SK\\d{22}$");
        ibanPatterns.put("SI", "^SI\\d{17}$");
        ibanPatterns.put("ES", "^ES\\d{22}$");
        ibanPatterns.put("SE", "^SE\\d{22}$");
        ibanPatterns.put("CH", "^CH\\d{7}[0-9A-Z]{12}$");
        ibanPatterns.put("TL", "^TL\\d{21}$");
        ibanPatterns.put("TN", "^TN\\d{22}$");
        ibanPatterns.put("TR", "^TR\\d{7}[0-9A-Z]{17}$");
        ibanPatterns.put("AE", "^AE\\d{21}$");
        ibanPatterns.put("GB", "^GB\\d{2}[A-Z]{4}\\d{14}$");
        ibanPatterns.put("VA", "^VA\\d{20}$");
        ibanPatterns.put("VG", "^VG\\d{2}[A-Z]{4}\\d{16}$");
        ibanPatterns.put("UA", "^UA\\d{8}[0-9A-Z]{19}$");
        ibanPatterns.put("SC", "^SC\\d{2}[A-Z]{4}\\d{20}[A-Z]{3}$");
        ibanPatterns.put("IQ", "^IQ\\d{2}[A-Z]{4}[0-9A-Z]{15}$");
        ibanPatterns.put("BY", "^BY\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("SV", "^SV\\d{2}[A-Z]{4}[0-9A-Z]{20}$");
        ibanPatterns.put("LY", "^LY\\d{23}$");
        ibanPatterns.put("SD", "^SD\\d{16}$");
        ibanPatterns.put("BI", "^BI\\d{2}[0-9A-Z]{10}[0-9A-Z]{12}$");
        ibanPatterns.put("DJ", "^DJ\\d{25}$");
        ibanPatterns.put("RU", "^RU\\d{2}[0-9A-Z]{20}[0-9A-Z]{9}$");

        // Validate IBAN format
        if (iban.length() < 2) return false; // IBAN too short to contain a valid country code
        String countryCode = iban.substring(0, 2);
        String regexPattern = ibanPatterns.get(countryCode);
        return regexPattern != null && iban.matches(regexPattern);
    }
}


class User {
    private String userId;
    private String username;
    private double balance;
    private String country;
    private boolean frozen;
    private double depositMin;
    private double depositMax;
    private double withdrawMin;
    private double withdrawMax;

    // Constructor
    public User(String userId, String username, double balance, String country, boolean frozen, double depositMin, double depositMax, double withdrawMin, double withdrawMax) {
        this.userId = userId;
        this.username = username;
        this.balance = balance;
        this.country = country;
        this.frozen = frozen;
        this.depositMin = depositMin;
        this.depositMax = depositMax;
        this.withdrawMin = withdrawMin;
        this.withdrawMax = withdrawMax;
    }
    // Getters and setters for each field
    public String getUserId() {
        return userId;
    }

    public String getUsername() {
        return username;
    }

    public double getBalance() {
        return balance;
    }

    public String getCountry() {
        return country;
    }

    public boolean isFrozen() {
        return frozen;
    }

    public double getDepositMin() {
        return depositMin;
    }

    public double getDepositMax() {
        return depositMax;
    }

    public double getWithdrawMin() {
        return withdrawMin;
    }

    public double getWithdrawMax() {
        return withdrawMax;
    }

    // Setters
    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    public void setCountry(String country) {
        this.country = country;
    }

    public void setFrozen(boolean frozen) {
        this.frozen = frozen;
    }

    public void setDepositMin(double depositMin) {
        this.depositMin = depositMin;
    }

    public void setDepositMax(double depositMax) {
        this.depositMax = depositMax;
    }

    public void setWithdrawMin(double withdrawMin) {
        this.withdrawMin = withdrawMin;
    }

    public void setWithdrawMax(double withdrawMax) {
        this.withdrawMax = withdrawMax;
    }
}

class Transaction {
    private String transactionId;
    private String userId;
    private String type;
    private double amount;
    private String method;
    private String accountNumber;

    // Adjusted constructor
    public Transaction(String transactionId, String userId, String type, double amount, String method, String accountNumber) {
        this.transactionId = transactionId;
        this.userId = userId;
        this.type = type;
        this.amount = amount;
        this.method = method;
        this.accountNumber = accountNumber;
    }

    // Getters
    public String getTransactionId() {
        return transactionId;
    }

    public String getUserId() {
        return userId;
    }

    public String getType() {
        return type;
    }

    public double getAmount() {
        return amount;
    }

    public String getMethod() {
        return method;
    }

    public String getAccountNumber() {
        return accountNumber;
    }

    // Setters
    public void setTransactionId(String transactionId) {
        this.transactionId = transactionId;
    }

    public void setUserId(String userId) {
        this.userId = userId;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setAmount(double amount) {
        this.amount = amount;
    }

    public void setMethod(String method) {
        this.method = method;
    }

    public void setAccountNumber(String accountNumber) {
        this.accountNumber = accountNumber;
    }
}

class BinMapping {
    private String name;
    private long rangeFrom;
    private long rangeTo;
    private String type;
    private String country;

    // Constructor
    public BinMapping(String name, long rangeFrom, long rangeTo, String type, String country) {
        this.name = name;
        this.rangeFrom = rangeFrom;
        this.rangeTo = rangeTo;
        this.type = type;
        this.country = country;
    }

    // Getters and setters
    public String getName() {
        return name;
    }

    public long getRangeFrom() {
        return rangeFrom;
    }

    public long getRangeTo() {
        return rangeTo;
    }

    public String getType() {
        return type;
    }

    public String getCountry() {
        return country;
    }

    // Setters
    public void setName(String name) {
        this.name = name;
    }

    public void setRangeFrom(long rangeFrom) {
        this.rangeFrom = rangeFrom;
    }

    public void setRangeTo(long rangeTo) {
        this.rangeTo = rangeTo;
    }

    public void setType(String type) {
        this.type = type;
    }

    public void setCountry(String country) {
        this.country = country;
    }
}

class Event {
    String transactionId;
    String status;
    String message;

    public Event(String transactionId, String status, String message) {
        this.transactionId = transactionId;
        this.status = status;
        this.message = message;
    }

    // Getters and Setters
    public String getTransactionId() { return transactionId; }
    public void setTransactionId(String transactionId) { this.transactionId = transactionId; }

    public String getStatus() { return status; }
    public void setStatus(String status) { this.status = status; }

    public String getMessage() { return message; }
    public void setMessage(String message) { this.message = message; }
}








